// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class MS_ADD_ITEM;
struct MS_ADD_ITEMDefaultTypeInternal;
extern MS_ADD_ITEMDefaultTypeInternal _MS_ADD_ITEM_default_instance_;
class MS_CHANGE_HP;
struct MS_CHANGE_HPDefaultTypeInternal;
extern MS_CHANGE_HPDefaultTypeInternal _MS_CHANGE_HP_default_instance_;
class MS_CHANGE_STAT;
struct MS_CHANGE_STATDefaultTypeInternal;
extern MS_CHANGE_STATDefaultTypeInternal _MS_CHANGE_STAT_default_instance_;
class MS_CONNECTED;
struct MS_CONNECTEDDefaultTypeInternal;
extern MS_CONNECTEDDefaultTypeInternal _MS_CONNECTED_default_instance_;
class MS_CREATE_PLAYER;
struct MS_CREATE_PLAYERDefaultTypeInternal;
extern MS_CREATE_PLAYERDefaultTypeInternal _MS_CREATE_PLAYER_default_instance_;
class MS_DESPAWN;
struct MS_DESPAWNDefaultTypeInternal;
extern MS_DESPAWNDefaultTypeInternal _MS_DESPAWN_default_instance_;
class MS_DIE;
struct MS_DIEDefaultTypeInternal;
extern MS_DIEDefaultTypeInternal _MS_DIE_default_instance_;
class MS_ENTER_GAME;
struct MS_ENTER_GAMEDefaultTypeInternal;
extern MS_ENTER_GAMEDefaultTypeInternal _MS_ENTER_GAME_default_instance_;
class MS_EQUIP_ITEM;
struct MS_EQUIP_ITEMDefaultTypeInternal;
extern MS_EQUIP_ITEMDefaultTypeInternal _MS_EQUIP_ITEM_default_instance_;
class MS_ITEM_LIST;
struct MS_ITEM_LISTDefaultTypeInternal;
extern MS_ITEM_LISTDefaultTypeInternal _MS_ITEM_LIST_default_instance_;
class MS_LEAVE_GAME;
struct MS_LEAVE_GAMEDefaultTypeInternal;
extern MS_LEAVE_GAMEDefaultTypeInternal _MS_LEAVE_GAME_default_instance_;
class MS_LOGIN;
struct MS_LOGINDefaultTypeInternal;
extern MS_LOGINDefaultTypeInternal _MS_LOGIN_default_instance_;
class MS_MOVE;
struct MS_MOVEDefaultTypeInternal;
extern MS_MOVEDefaultTypeInternal _MS_MOVE_default_instance_;
class MS_PING;
struct MS_PINGDefaultTypeInternal;
extern MS_PINGDefaultTypeInternal _MS_PING_default_instance_;
class MS_SKILL;
struct MS_SKILLDefaultTypeInternal;
extern MS_SKILLDefaultTypeInternal _MS_SKILL_default_instance_;
class MS_SPAWN;
struct MS_SPAWNDefaultTypeInternal;
extern MS_SPAWNDefaultTypeInternal _MS_SPAWN_default_instance_;
class UC_CHANGE_ROOM;
struct UC_CHANGE_ROOMDefaultTypeInternal;
extern UC_CHANGE_ROOMDefaultTypeInternal _UC_CHANGE_ROOM_default_instance_;
class UC_CREATE_PLAYER;
struct UC_CREATE_PLAYERDefaultTypeInternal;
extern UC_CREATE_PLAYERDefaultTypeInternal _UC_CREATE_PLAYER_default_instance_;
class UC_ENTER_GAME;
struct UC_ENTER_GAMEDefaultTypeInternal;
extern UC_ENTER_GAMEDefaultTypeInternal _UC_ENTER_GAME_default_instance_;
class UC_EQUIP_ITEM;
struct UC_EQUIP_ITEMDefaultTypeInternal;
extern UC_EQUIP_ITEMDefaultTypeInternal _UC_EQUIP_ITEM_default_instance_;
class UC_LOGIN;
struct UC_LOGINDefaultTypeInternal;
extern UC_LOGINDefaultTypeInternal _UC_LOGIN_default_instance_;
class UC_MOVE;
struct UC_MOVEDefaultTypeInternal;
extern UC_MOVEDefaultTypeInternal _UC_MOVE_default_instance_;
class UC_PONG;
struct UC_PONGDefaultTypeInternal;
extern UC_PONGDefaultTypeInternal _UC_PONG_default_instance_;
class UC_SKILL;
struct UC_SKILLDefaultTypeInternal;
extern UC_SKILLDefaultTypeInternal _UC_SKILL_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::MS_ADD_ITEM* Arena::CreateMaybeMessage<::Protocol::MS_ADD_ITEM>(Arena*);
template<> ::Protocol::MS_CHANGE_HP* Arena::CreateMaybeMessage<::Protocol::MS_CHANGE_HP>(Arena*);
template<> ::Protocol::MS_CHANGE_STAT* Arena::CreateMaybeMessage<::Protocol::MS_CHANGE_STAT>(Arena*);
template<> ::Protocol::MS_CONNECTED* Arena::CreateMaybeMessage<::Protocol::MS_CONNECTED>(Arena*);
template<> ::Protocol::MS_CREATE_PLAYER* Arena::CreateMaybeMessage<::Protocol::MS_CREATE_PLAYER>(Arena*);
template<> ::Protocol::MS_DESPAWN* Arena::CreateMaybeMessage<::Protocol::MS_DESPAWN>(Arena*);
template<> ::Protocol::MS_DIE* Arena::CreateMaybeMessage<::Protocol::MS_DIE>(Arena*);
template<> ::Protocol::MS_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::MS_ENTER_GAME>(Arena*);
template<> ::Protocol::MS_EQUIP_ITEM* Arena::CreateMaybeMessage<::Protocol::MS_EQUIP_ITEM>(Arena*);
template<> ::Protocol::MS_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::MS_ITEM_LIST>(Arena*);
template<> ::Protocol::MS_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::MS_LEAVE_GAME>(Arena*);
template<> ::Protocol::MS_LOGIN* Arena::CreateMaybeMessage<::Protocol::MS_LOGIN>(Arena*);
template<> ::Protocol::MS_MOVE* Arena::CreateMaybeMessage<::Protocol::MS_MOVE>(Arena*);
template<> ::Protocol::MS_PING* Arena::CreateMaybeMessage<::Protocol::MS_PING>(Arena*);
template<> ::Protocol::MS_SKILL* Arena::CreateMaybeMessage<::Protocol::MS_SKILL>(Arena*);
template<> ::Protocol::MS_SPAWN* Arena::CreateMaybeMessage<::Protocol::MS_SPAWN>(Arena*);
template<> ::Protocol::UC_CHANGE_ROOM* Arena::CreateMaybeMessage<::Protocol::UC_CHANGE_ROOM>(Arena*);
template<> ::Protocol::UC_CREATE_PLAYER* Arena::CreateMaybeMessage<::Protocol::UC_CREATE_PLAYER>(Arena*);
template<> ::Protocol::UC_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::UC_ENTER_GAME>(Arena*);
template<> ::Protocol::UC_EQUIP_ITEM* Arena::CreateMaybeMessage<::Protocol::UC_EQUIP_ITEM>(Arena*);
template<> ::Protocol::UC_LOGIN* Arena::CreateMaybeMessage<::Protocol::UC_LOGIN>(Arena*);
template<> ::Protocol::UC_MOVE* Arena::CreateMaybeMessage<::Protocol::UC_MOVE>(Arena*);
template<> ::Protocol::UC_PONG* Arena::CreateMaybeMessage<::Protocol::UC_PONG>(Arena*);
template<> ::Protocol::UC_SKILL* Arena::CreateMaybeMessage<::Protocol::UC_SKILL>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class MS_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_ENTER_GAME) */ {
 public:
  inline MS_ENTER_GAME() : MS_ENTER_GAME(nullptr) {}
  ~MS_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR MS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_ENTER_GAME(const MS_ENTER_GAME& from);
  MS_ENTER_GAME(MS_ENTER_GAME&& from) noexcept
    : MS_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline MS_ENTER_GAME& operator=(const MS_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_ENTER_GAME& operator=(MS_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const MS_ENTER_GAME*>(
               &_MS_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MS_ENTER_GAME& a, MS_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_ENTER_GAME& from) {
    MS_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_ENTER_GAME";
  }
  protected:
  explicit MS_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.MS_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.MS_LEAVE_GAME) */ {
 public:
  inline MS_LEAVE_GAME() : MS_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_LEAVE_GAME(const MS_LEAVE_GAME& from);
  MS_LEAVE_GAME(MS_LEAVE_GAME&& from) noexcept
    : MS_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline MS_LEAVE_GAME& operator=(const MS_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_LEAVE_GAME& operator=(MS_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const MS_LEAVE_GAME*>(
               &_MS_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MS_LEAVE_GAME& a, MS_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MS_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MS_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_LEAVE_GAME";
  }
  protected:
  explicit MS_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.MS_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_SPAWN) */ {
 public:
  inline MS_SPAWN() : MS_SPAWN(nullptr) {}
  ~MS_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR MS_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_SPAWN(const MS_SPAWN& from);
  MS_SPAWN(MS_SPAWN&& from) noexcept
    : MS_SPAWN() {
    *this = ::std::move(from);
  }

  inline MS_SPAWN& operator=(const MS_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_SPAWN& operator=(MS_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_SPAWN* internal_default_instance() {
    return reinterpret_cast<const MS_SPAWN*>(
               &_MS_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MS_SPAWN& a, MS_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_SPAWN& from) {
    MS_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_SPAWN";
  }
  protected:
  explicit MS_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::Protocol::ObjectInfo* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objects();
  private:
  const ::Protocol::ObjectInfo& _internal_objects(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objects();
  public:
  const ::Protocol::ObjectInfo& objects(int index) const;
  ::Protocol::ObjectInfo* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Protocol.MS_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_DESPAWN) */ {
 public:
  inline MS_DESPAWN() : MS_DESPAWN(nullptr) {}
  ~MS_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR MS_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_DESPAWN(const MS_DESPAWN& from);
  MS_DESPAWN(MS_DESPAWN&& from) noexcept
    : MS_DESPAWN() {
    *this = ::std::move(from);
  }

  inline MS_DESPAWN& operator=(const MS_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_DESPAWN& operator=(MS_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const MS_DESPAWN*>(
               &_MS_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MS_DESPAWN& a, MS_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_DESPAWN& from) {
    MS_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_DESPAWN";
  }
  protected:
  explicit MS_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated int32 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  int32_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_object_ids();
  public:
  int32_t object_ids(int index) const;
  void set_object_ids(int index, int32_t value);
  void add_object_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.MS_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_MOVE) */ {
 public:
  inline UC_MOVE() : UC_MOVE(nullptr) {}
  ~UC_MOVE() override;
  explicit PROTOBUF_CONSTEXPR UC_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_MOVE(const UC_MOVE& from);
  UC_MOVE(UC_MOVE&& from) noexcept
    : UC_MOVE() {
    *this = ::std::move(from);
  }

  inline UC_MOVE& operator=(const UC_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_MOVE& operator=(UC_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_MOVE* internal_default_instance() {
    return reinterpret_cast<const UC_MOVE*>(
               &_UC_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UC_MOVE& a, UC_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_MOVE& from) {
    UC_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_MOVE";
  }
  protected:
  explicit UC_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo pos_info = 1;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PositionInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_pos_info();
  ::Protocol::PositionInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PositionInfo* pos_info);
  private:
  const ::Protocol::PositionInfo& _internal_pos_info() const;
  ::Protocol::PositionInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PositionInfo* pos_info);
  ::Protocol::PositionInfo* unsafe_arena_release_pos_info();

  // @@protoc_insertion_point(class_scope:Protocol.UC_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* pos_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_MOVE) */ {
 public:
  inline MS_MOVE() : MS_MOVE(nullptr) {}
  ~MS_MOVE() override;
  explicit PROTOBUF_CONSTEXPR MS_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_MOVE(const MS_MOVE& from);
  MS_MOVE(MS_MOVE&& from) noexcept
    : MS_MOVE() {
    *this = ::std::move(from);
  }

  inline MS_MOVE& operator=(const MS_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_MOVE& operator=(MS_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_MOVE* internal_default_instance() {
    return reinterpret_cast<const MS_MOVE*>(
               &_MS_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MS_MOVE& a, MS_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_MOVE& from) {
    MS_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_MOVE";
  }
  protected:
  explicit MS_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo pos_info = 2;
  bool has_pos_info() const;
  private:
  bool _internal_has_pos_info() const;
  public:
  void clear_pos_info();
  const ::Protocol::PositionInfo& pos_info() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_pos_info();
  ::Protocol::PositionInfo* mutable_pos_info();
  void set_allocated_pos_info(::Protocol::PositionInfo* pos_info);
  private:
  const ::Protocol::PositionInfo& _internal_pos_info() const;
  ::Protocol::PositionInfo* _internal_mutable_pos_info();
  public:
  void unsafe_arena_set_allocated_pos_info(
      ::Protocol::PositionInfo* pos_info);
  ::Protocol::PositionInfo* unsafe_arena_release_pos_info();

  // int32 object_id = 1;
  void clear_object_id();
  int32_t object_id() const;
  void set_object_id(int32_t value);
  private:
  int32_t _internal_object_id() const;
  void _internal_set_object_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* pos_info_;
    int32_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_SKILL) */ {
 public:
  inline UC_SKILL() : UC_SKILL(nullptr) {}
  ~UC_SKILL() override;
  explicit PROTOBUF_CONSTEXPR UC_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_SKILL(const UC_SKILL& from);
  UC_SKILL(UC_SKILL&& from) noexcept
    : UC_SKILL() {
    *this = ::std::move(from);
  }

  inline UC_SKILL& operator=(const UC_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_SKILL& operator=(UC_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_SKILL* internal_default_instance() {
    return reinterpret_cast<const UC_SKILL*>(
               &_UC_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UC_SKILL& a, UC_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_SKILL& from) {
    UC_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_SKILL";
  }
  protected:
  explicit UC_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.UC_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_SKILL) */ {
 public:
  inline MS_SKILL() : MS_SKILL(nullptr) {}
  ~MS_SKILL() override;
  explicit PROTOBUF_CONSTEXPR MS_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_SKILL(const MS_SKILL& from);
  MS_SKILL(MS_SKILL&& from) noexcept
    : MS_SKILL() {
    *this = ::std::move(from);
  }

  inline MS_SKILL& operator=(const MS_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_SKILL& operator=(MS_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_SKILL* internal_default_instance() {
    return reinterpret_cast<const MS_SKILL*>(
               &_MS_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MS_SKILL& a, MS_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_SKILL& from) {
    MS_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_SKILL";
  }
  protected:
  explicit MS_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.SkillInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::SkillInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_info();
  ::Protocol::SkillInfo* mutable_info();
  void set_allocated_info(::Protocol::SkillInfo* info);
  private:
  const ::Protocol::SkillInfo& _internal_info() const;
  ::Protocol::SkillInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::SkillInfo* info);
  ::Protocol::SkillInfo* unsafe_arena_release_info();

  // int32 object_id = 1;
  void clear_object_id();
  int32_t object_id() const;
  void set_object_id(int32_t value);
  private:
  int32_t _internal_object_id() const;
  void _internal_set_object_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* info_;
    int32_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_DIE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_DIE) */ {
 public:
  inline MS_DIE() : MS_DIE(nullptr) {}
  ~MS_DIE() override;
  explicit PROTOBUF_CONSTEXPR MS_DIE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_DIE(const MS_DIE& from);
  MS_DIE(MS_DIE&& from) noexcept
    : MS_DIE() {
    *this = ::std::move(from);
  }

  inline MS_DIE& operator=(const MS_DIE& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_DIE& operator=(MS_DIE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_DIE& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_DIE* internal_default_instance() {
    return reinterpret_cast<const MS_DIE*>(
               &_MS_DIE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MS_DIE& a, MS_DIE& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_DIE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_DIE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_DIE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_DIE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_DIE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_DIE& from) {
    MS_DIE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_DIE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_DIE";
  }
  protected:
  explicit MS_DIE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
  };
  // int32 object_id = 1;
  void clear_object_id();
  int32_t object_id() const;
  void set_object_id(int32_t value);
  private:
  int32_t _internal_object_id() const;
  void _internal_set_object_id(int32_t value);
  public:

  // int32 attacker_id = 2;
  void clear_attacker_id();
  int32_t attacker_id() const;
  void set_attacker_id(int32_t value);
  private:
  int32_t _internal_attacker_id() const;
  void _internal_set_attacker_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_DIE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t object_id_;
    int32_t attacker_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_CHANGE_HP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_CHANGE_HP) */ {
 public:
  inline MS_CHANGE_HP() : MS_CHANGE_HP(nullptr) {}
  ~MS_CHANGE_HP() override;
  explicit PROTOBUF_CONSTEXPR MS_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_CHANGE_HP(const MS_CHANGE_HP& from);
  MS_CHANGE_HP(MS_CHANGE_HP&& from) noexcept
    : MS_CHANGE_HP() {
    *this = ::std::move(from);
  }

  inline MS_CHANGE_HP& operator=(const MS_CHANGE_HP& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_CHANGE_HP& operator=(MS_CHANGE_HP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_CHANGE_HP& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_CHANGE_HP* internal_default_instance() {
    return reinterpret_cast<const MS_CHANGE_HP*>(
               &_MS_CHANGE_HP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MS_CHANGE_HP& a, MS_CHANGE_HP& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_CHANGE_HP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_CHANGE_HP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_CHANGE_HP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_CHANGE_HP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_CHANGE_HP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_CHANGE_HP& from) {
    MS_CHANGE_HP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_CHANGE_HP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_CHANGE_HP";
  }
  protected:
  explicit MS_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 object_id = 1;
  void clear_object_id();
  int32_t object_id() const;
  void set_object_id(int32_t value);
  private:
  int32_t _internal_object_id() const;
  void _internal_set_object_id(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_CHANGE_HP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t object_id_;
    int32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_CONNECTED final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.MS_CONNECTED) */ {
 public:
  inline MS_CONNECTED() : MS_CONNECTED(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MS_CONNECTED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_CONNECTED(const MS_CONNECTED& from);
  MS_CONNECTED(MS_CONNECTED&& from) noexcept
    : MS_CONNECTED() {
    *this = ::std::move(from);
  }

  inline MS_CONNECTED& operator=(const MS_CONNECTED& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_CONNECTED& operator=(MS_CONNECTED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_CONNECTED& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_CONNECTED* internal_default_instance() {
    return reinterpret_cast<const MS_CONNECTED*>(
               &_MS_CONNECTED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MS_CONNECTED& a, MS_CONNECTED& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_CONNECTED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_CONNECTED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_CONNECTED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_CONNECTED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MS_CONNECTED& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MS_CONNECTED& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_CONNECTED";
  }
  protected:
  explicit MS_CONNECTED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.MS_CONNECTED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_LOGIN) */ {
 public:
  inline UC_LOGIN() : UC_LOGIN(nullptr) {}
  ~UC_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR UC_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_LOGIN(const UC_LOGIN& from);
  UC_LOGIN(UC_LOGIN&& from) noexcept
    : UC_LOGIN() {
    *this = ::std::move(from);
  }

  inline UC_LOGIN& operator=(const UC_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_LOGIN& operator=(UC_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_LOGIN* internal_default_instance() {
    return reinterpret_cast<const UC_LOGIN*>(
               &_UC_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UC_LOGIN& a, UC_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_LOGIN& from) {
    UC_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_LOGIN";
  }
  protected:
  explicit UC_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // string unique_id = 1;
  void clear_unique_id();
  const std::string& unique_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_id();
  PROTOBUF_NODISCARD std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // int32 room_id = 2;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UC_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
    int32_t room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_LOGIN) */ {
 public:
  inline MS_LOGIN() : MS_LOGIN(nullptr) {}
  ~MS_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR MS_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_LOGIN(const MS_LOGIN& from);
  MS_LOGIN(MS_LOGIN&& from) noexcept
    : MS_LOGIN() {
    *this = ::std::move(from);
  }

  inline MS_LOGIN& operator=(const MS_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_LOGIN& operator=(MS_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_LOGIN* internal_default_instance() {
    return reinterpret_cast<const MS_LOGIN*>(
               &_MS_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MS_LOGIN& a, MS_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_LOGIN& from) {
    MS_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_LOGIN";
  }
  protected:
  explicit MS_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kLoginOkFieldNumber = 1,
  };
  // repeated .Protocol.LobbyPlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::LobbyPlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_players(int index) const;
  ::Protocol::LobbyPlayerInfo* _internal_add_players();
  public:
  const ::Protocol::LobbyPlayerInfo& players(int index) const;
  ::Protocol::LobbyPlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
      players() const;

  // int32 login_ok = 1;
  void clear_login_ok();
  int32_t login_ok() const;
  void set_login_ok(int32_t value);
  private:
  int32_t _internal_login_ok() const;
  void _internal_set_login_ok(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo > players_;
    int32_t login_ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_CREATE_PLAYER) */ {
 public:
  inline UC_CREATE_PLAYER() : UC_CREATE_PLAYER(nullptr) {}
  ~UC_CREATE_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR UC_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_CREATE_PLAYER(const UC_CREATE_PLAYER& from);
  UC_CREATE_PLAYER(UC_CREATE_PLAYER&& from) noexcept
    : UC_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline UC_CREATE_PLAYER& operator=(const UC_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_CREATE_PLAYER& operator=(UC_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const UC_CREATE_PLAYER*>(
               &_UC_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UC_CREATE_PLAYER& a, UC_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_CREATE_PLAYER& from) {
    UC_CREATE_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_CREATE_PLAYER";
  }
  protected:
  explicit UC_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UC_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_CREATE_PLAYER) */ {
 public:
  inline MS_CREATE_PLAYER() : MS_CREATE_PLAYER(nullptr) {}
  ~MS_CREATE_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR MS_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_CREATE_PLAYER(const MS_CREATE_PLAYER& from);
  MS_CREATE_PLAYER(MS_CREATE_PLAYER&& from) noexcept
    : MS_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline MS_CREATE_PLAYER& operator=(const MS_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_CREATE_PLAYER& operator=(MS_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const MS_CREATE_PLAYER*>(
               &_MS_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MS_CREATE_PLAYER& a, MS_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_CREATE_PLAYER& from) {
    MS_CREATE_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_CREATE_PLAYER";
  }
  protected:
  explicit MS_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.LobbyPlayerInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::LobbyPlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::LobbyPlayerInfo* release_player();
  ::Protocol::LobbyPlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::LobbyPlayerInfo* player);
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_player() const;
  ::Protocol::LobbyPlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::LobbyPlayerInfo* player);
  ::Protocol::LobbyPlayerInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.MS_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::LobbyPlayerInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_ENTER_GAME) */ {
 public:
  inline UC_ENTER_GAME() : UC_ENTER_GAME(nullptr) {}
  ~UC_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR UC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_ENTER_GAME(const UC_ENTER_GAME& from);
  UC_ENTER_GAME(UC_ENTER_GAME&& from) noexcept
    : UC_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline UC_ENTER_GAME& operator=(const UC_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_ENTER_GAME& operator=(UC_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const UC_ENTER_GAME*>(
               &_UC_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UC_ENTER_GAME& a, UC_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_ENTER_GAME& from) {
    UC_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_ENTER_GAME";
  }
  protected:
  explicit UC_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UC_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_ITEM_LIST) */ {
 public:
  inline MS_ITEM_LIST() : MS_ITEM_LIST(nullptr) {}
  ~MS_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR MS_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_ITEM_LIST(const MS_ITEM_LIST& from);
  MS_ITEM_LIST(MS_ITEM_LIST&& from) noexcept
    : MS_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline MS_ITEM_LIST& operator=(const MS_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_ITEM_LIST& operator=(MS_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const MS_ITEM_LIST*>(
               &_MS_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MS_ITEM_LIST& a, MS_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_ITEM_LIST& from) {
    MS_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_ITEM_LIST";
  }
  protected:
  explicit MS_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.MS_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_ADD_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_ADD_ITEM) */ {
 public:
  inline MS_ADD_ITEM() : MS_ADD_ITEM(nullptr) {}
  ~MS_ADD_ITEM() override;
  explicit PROTOBUF_CONSTEXPR MS_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_ADD_ITEM(const MS_ADD_ITEM& from);
  MS_ADD_ITEM(MS_ADD_ITEM&& from) noexcept
    : MS_ADD_ITEM() {
    *this = ::std::move(from);
  }

  inline MS_ADD_ITEM& operator=(const MS_ADD_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_ADD_ITEM& operator=(MS_ADD_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_ADD_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_ADD_ITEM* internal_default_instance() {
    return reinterpret_cast<const MS_ADD_ITEM*>(
               &_MS_ADD_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MS_ADD_ITEM& a, MS_ADD_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_ADD_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_ADD_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_ADD_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_ADD_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_ADD_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_ADD_ITEM& from) {
    MS_ADD_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_ADD_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_ADD_ITEM";
  }
  protected:
  explicit MS_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.MS_ADD_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_EQUIP_ITEM) */ {
 public:
  inline UC_EQUIP_ITEM() : UC_EQUIP_ITEM(nullptr) {}
  ~UC_EQUIP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR UC_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_EQUIP_ITEM(const UC_EQUIP_ITEM& from);
  UC_EQUIP_ITEM(UC_EQUIP_ITEM&& from) noexcept
    : UC_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline UC_EQUIP_ITEM& operator=(const UC_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_EQUIP_ITEM& operator=(UC_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const UC_EQUIP_ITEM*>(
               &_UC_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UC_EQUIP_ITEM& a, UC_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_EQUIP_ITEM& from) {
    UC_EQUIP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_EQUIP_ITEM";
  }
  protected:
  explicit UC_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 item_db_id = 1;
  void clear_item_db_id();
  int32_t item_db_id() const;
  void set_item_db_id(int32_t value);
  private:
  int32_t _internal_item_db_id() const;
  void _internal_set_item_db_id(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UC_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_db_id_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_EQUIP_ITEM) */ {
 public:
  inline MS_EQUIP_ITEM() : MS_EQUIP_ITEM(nullptr) {}
  ~MS_EQUIP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR MS_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_EQUIP_ITEM(const MS_EQUIP_ITEM& from);
  MS_EQUIP_ITEM(MS_EQUIP_ITEM&& from) noexcept
    : MS_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline MS_EQUIP_ITEM& operator=(const MS_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_EQUIP_ITEM& operator=(MS_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const MS_EQUIP_ITEM*>(
               &_MS_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MS_EQUIP_ITEM& a, MS_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_EQUIP_ITEM& from) {
    MS_EQUIP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_EQUIP_ITEM";
  }
  protected:
  explicit MS_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 item_db_id = 1;
  void clear_item_db_id();
  int32_t item_db_id() const;
  void set_item_db_id(int32_t value);
  private:
  int32_t _internal_item_db_id() const;
  void _internal_set_item_db_id(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.MS_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_db_id_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_CHANGE_STAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.MS_CHANGE_STAT) */ {
 public:
  inline MS_CHANGE_STAT() : MS_CHANGE_STAT(nullptr) {}
  ~MS_CHANGE_STAT() override;
  explicit PROTOBUF_CONSTEXPR MS_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_CHANGE_STAT(const MS_CHANGE_STAT& from);
  MS_CHANGE_STAT(MS_CHANGE_STAT&& from) noexcept
    : MS_CHANGE_STAT() {
    *this = ::std::move(from);
  }

  inline MS_CHANGE_STAT& operator=(const MS_CHANGE_STAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_CHANGE_STAT& operator=(MS_CHANGE_STAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_CHANGE_STAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_CHANGE_STAT* internal_default_instance() {
    return reinterpret_cast<const MS_CHANGE_STAT*>(
               &_MS_CHANGE_STAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MS_CHANGE_STAT& a, MS_CHANGE_STAT& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_CHANGE_STAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_CHANGE_STAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_CHANGE_STAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_CHANGE_STAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MS_CHANGE_STAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MS_CHANGE_STAT& from) {
    MS_CHANGE_STAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MS_CHANGE_STAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_CHANGE_STAT";
  }
  protected:
  explicit MS_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatInfoFieldNumber = 1,
  };
  // .Protocol.StatInfo stat_info = 1;
  bool has_stat_info() const;
  private:
  bool _internal_has_stat_info() const;
  public:
  void clear_stat_info();
  const ::Protocol::StatInfo& stat_info() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_stat_info();
  ::Protocol::StatInfo* mutable_stat_info();
  void set_allocated_stat_info(::Protocol::StatInfo* stat_info);
  private:
  const ::Protocol::StatInfo& _internal_stat_info() const;
  ::Protocol::StatInfo* _internal_mutable_stat_info();
  public:
  void unsafe_arena_set_allocated_stat_info(
      ::Protocol::StatInfo* stat_info);
  ::Protocol::StatInfo* unsafe_arena_release_stat_info();

  // @@protoc_insertion_point(class_scope:Protocol.MS_CHANGE_STAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatInfo* stat_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class MS_PING final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.MS_PING) */ {
 public:
  inline MS_PING() : MS_PING(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MS_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MS_PING(const MS_PING& from);
  MS_PING(MS_PING&& from) noexcept
    : MS_PING() {
    *this = ::std::move(from);
  }

  inline MS_PING& operator=(const MS_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline MS_PING& operator=(MS_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MS_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const MS_PING* internal_default_instance() {
    return reinterpret_cast<const MS_PING*>(
               &_MS_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MS_PING& a, MS_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(MS_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MS_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MS_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MS_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MS_PING& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MS_PING& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.MS_PING";
  }
  protected:
  explicit MS_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.MS_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_PONG final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.UC_PONG) */ {
 public:
  inline UC_PONG() : UC_PONG(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UC_PONG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_PONG(const UC_PONG& from);
  UC_PONG(UC_PONG&& from) noexcept
    : UC_PONG() {
    *this = ::std::move(from);
  }

  inline UC_PONG& operator=(const UC_PONG& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_PONG& operator=(UC_PONG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_PONG& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_PONG* internal_default_instance() {
    return reinterpret_cast<const UC_PONG*>(
               &_UC_PONG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UC_PONG& a, UC_PONG& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_PONG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_PONG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_PONG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_PONG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UC_PONG& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UC_PONG& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_PONG";
  }
  protected:
  explicit UC_PONG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.UC_PONG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UC_CHANGE_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UC_CHANGE_ROOM) */ {
 public:
  inline UC_CHANGE_ROOM() : UC_CHANGE_ROOM(nullptr) {}
  ~UC_CHANGE_ROOM() override;
  explicit PROTOBUF_CONSTEXPR UC_CHANGE_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UC_CHANGE_ROOM(const UC_CHANGE_ROOM& from);
  UC_CHANGE_ROOM(UC_CHANGE_ROOM&& from) noexcept
    : UC_CHANGE_ROOM() {
    *this = ::std::move(from);
  }

  inline UC_CHANGE_ROOM& operator=(const UC_CHANGE_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline UC_CHANGE_ROOM& operator=(UC_CHANGE_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UC_CHANGE_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const UC_CHANGE_ROOM* internal_default_instance() {
    return reinterpret_cast<const UC_CHANGE_ROOM*>(
               &_UC_CHANGE_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UC_CHANGE_ROOM& a, UC_CHANGE_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(UC_CHANGE_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UC_CHANGE_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UC_CHANGE_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UC_CHANGE_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UC_CHANGE_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UC_CHANGE_ROOM& from) {
    UC_CHANGE_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UC_CHANGE_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UC_CHANGE_ROOM";
  }
  protected:
  explicit UC_CHANGE_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UC_CHANGE_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MS_ENTER_GAME

// .Protocol.ObjectInfo player = 1;
inline bool MS_ENTER_GAME::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool MS_ENTER_GAME::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& MS_ENTER_GAME::_internal_player() const {
  const ::Protocol::ObjectInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& MS_ENTER_GAME::player() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_ENTER_GAME.player)
  return _internal_player();
}
inline void MS_ENTER_GAME::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MS_ENTER_GAME.player)
}
inline ::Protocol::ObjectInfo* MS_ENTER_GAME::release_player() {
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* MS_ENTER_GAME::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.MS_ENTER_GAME.player)
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* MS_ENTER_GAME::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ObjectInfo* MS_ENTER_GAME::mutable_player() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.MS_ENTER_GAME.player)
  return _msg;
}
inline void MS_ENTER_GAME::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MS_ENTER_GAME.player)
}

// -------------------------------------------------------------------

// MS_LEAVE_GAME

// -------------------------------------------------------------------

// MS_SPAWN

// repeated .Protocol.ObjectInfo objects = 1;
inline int MS_SPAWN::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int MS_SPAWN::objects_size() const {
  return _internal_objects_size();
}
inline ::Protocol::ObjectInfo* MS_SPAWN::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MS_SPAWN.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
MS_SPAWN::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MS_SPAWN.objects)
  return &_impl_.objects_;
}
inline const ::Protocol::ObjectInfo& MS_SPAWN::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::Protocol::ObjectInfo& MS_SPAWN::objects(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MS_SPAWN.objects)
  return _internal_objects(index);
}
inline ::Protocol::ObjectInfo* MS_SPAWN::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::Protocol::ObjectInfo* MS_SPAWN::add_objects() {
  ::Protocol::ObjectInfo* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:Protocol.MS_SPAWN.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
MS_SPAWN::objects() const {
  // @@protoc_insertion_point(field_list:Protocol.MS_SPAWN.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// MS_DESPAWN

// repeated int32 object_ids = 1;
inline int MS_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int MS_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void MS_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline int32_t MS_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline int32_t MS_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MS_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void MS_DESPAWN::set_object_ids(int index, int32_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.MS_DESPAWN.object_ids)
}
inline void MS_DESPAWN::_internal_add_object_ids(int32_t value) {
  _impl_.object_ids_.Add(value);
}
inline void MS_DESPAWN::add_object_ids(int32_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.MS_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MS_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MS_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.MS_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MS_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MS_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MS_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// UC_MOVE

// .Protocol.PositionInfo pos_info = 1;
inline bool UC_MOVE::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool UC_MOVE::has_pos_info() const {
  return _internal_has_pos_info();
}
inline const ::Protocol::PositionInfo& UC_MOVE::_internal_pos_info() const {
  const ::Protocol::PositionInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& UC_MOVE::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_MOVE.pos_info)
  return _internal_pos_info();
}
inline void UC_MOVE::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PositionInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.UC_MOVE.pos_info)
}
inline ::Protocol::PositionInfo* UC_MOVE::release_pos_info() {
  
  ::Protocol::PositionInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* UC_MOVE::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.UC_MOVE.pos_info)
  
  ::Protocol::PositionInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* UC_MOVE::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PositionInfo* UC_MOVE::mutable_pos_info() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.UC_MOVE.pos_info)
  return _msg;
}
inline void UC_MOVE::set_allocated_pos_info(::Protocol::PositionInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_info));
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.UC_MOVE.pos_info)
}

// -------------------------------------------------------------------

// MS_MOVE

// int32 object_id = 1;
inline void MS_MOVE::clear_object_id() {
  _impl_.object_id_ = 0;
}
inline int32_t MS_MOVE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline int32_t MS_MOVE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_MOVE.object_id)
  return _internal_object_id();
}
inline void MS_MOVE::_internal_set_object_id(int32_t value) {
  
  _impl_.object_id_ = value;
}
inline void MS_MOVE::set_object_id(int32_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_MOVE.object_id)
}

// .Protocol.PositionInfo pos_info = 2;
inline bool MS_MOVE::_internal_has_pos_info() const {
  return this != internal_default_instance() && _impl_.pos_info_ != nullptr;
}
inline bool MS_MOVE::has_pos_info() const {
  return _internal_has_pos_info();
}
inline const ::Protocol::PositionInfo& MS_MOVE::_internal_pos_info() const {
  const ::Protocol::PositionInfo* p = _impl_.pos_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& MS_MOVE::pos_info() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_MOVE.pos_info)
  return _internal_pos_info();
}
inline void MS_MOVE::unsafe_arena_set_allocated_pos_info(
    ::Protocol::PositionInfo* pos_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  _impl_.pos_info_ = pos_info;
  if (pos_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MS_MOVE.pos_info)
}
inline ::Protocol::PositionInfo* MS_MOVE::release_pos_info() {
  
  ::Protocol::PositionInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* MS_MOVE::unsafe_arena_release_pos_info() {
  // @@protoc_insertion_point(field_release:Protocol.MS_MOVE.pos_info)
  
  ::Protocol::PositionInfo* temp = _impl_.pos_info_;
  _impl_.pos_info_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* MS_MOVE::_internal_mutable_pos_info() {
  
  if (_impl_.pos_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.pos_info_ = p;
  }
  return _impl_.pos_info_;
}
inline ::Protocol::PositionInfo* MS_MOVE::mutable_pos_info() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_pos_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MS_MOVE.pos_info)
  return _msg;
}
inline void MS_MOVE::set_allocated_pos_info(::Protocol::PositionInfo* pos_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_info_);
  }
  if (pos_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_info));
    if (message_arena != submessage_arena) {
      pos_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_info_ = pos_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MS_MOVE.pos_info)
}

// -------------------------------------------------------------------

// UC_SKILL

// .Protocol.SkillInfo info = 1;
inline bool UC_SKILL::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool UC_SKILL::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::SkillInfo& UC_SKILL::_internal_info() const {
  const ::Protocol::SkillInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& UC_SKILL::info() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_SKILL.info)
  return _internal_info();
}
inline void UC_SKILL::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.UC_SKILL.info)
}
inline ::Protocol::SkillInfo* UC_SKILL::release_info() {
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* UC_SKILL::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.UC_SKILL.info)
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* UC_SKILL::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::SkillInfo* UC_SKILL::mutable_info() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.UC_SKILL.info)
  return _msg;
}
inline void UC_SKILL::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.UC_SKILL.info)
}

// -------------------------------------------------------------------

// MS_SKILL

// int32 object_id = 1;
inline void MS_SKILL::clear_object_id() {
  _impl_.object_id_ = 0;
}
inline int32_t MS_SKILL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline int32_t MS_SKILL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_SKILL.object_id)
  return _internal_object_id();
}
inline void MS_SKILL::_internal_set_object_id(int32_t value) {
  
  _impl_.object_id_ = value;
}
inline void MS_SKILL::set_object_id(int32_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_SKILL.object_id)
}

// .Protocol.SkillInfo info = 2;
inline bool MS_SKILL::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool MS_SKILL::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::SkillInfo& MS_SKILL::_internal_info() const {
  const ::Protocol::SkillInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& MS_SKILL::info() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_SKILL.info)
  return _internal_info();
}
inline void MS_SKILL::unsafe_arena_set_allocated_info(
    ::Protocol::SkillInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MS_SKILL.info)
}
inline ::Protocol::SkillInfo* MS_SKILL::release_info() {
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* MS_SKILL::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.MS_SKILL.info)
  
  ::Protocol::SkillInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* MS_SKILL::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::SkillInfo* MS_SKILL::mutable_info() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MS_SKILL.info)
  return _msg;
}
inline void MS_SKILL::set_allocated_info(::Protocol::SkillInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MS_SKILL.info)
}

// -------------------------------------------------------------------

// MS_DIE

// int32 object_id = 1;
inline void MS_DIE::clear_object_id() {
  _impl_.object_id_ = 0;
}
inline int32_t MS_DIE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline int32_t MS_DIE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_DIE.object_id)
  return _internal_object_id();
}
inline void MS_DIE::_internal_set_object_id(int32_t value) {
  
  _impl_.object_id_ = value;
}
inline void MS_DIE::set_object_id(int32_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_DIE.object_id)
}

// int32 attacker_id = 2;
inline void MS_DIE::clear_attacker_id() {
  _impl_.attacker_id_ = 0;
}
inline int32_t MS_DIE::_internal_attacker_id() const {
  return _impl_.attacker_id_;
}
inline int32_t MS_DIE::attacker_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_DIE.attacker_id)
  return _internal_attacker_id();
}
inline void MS_DIE::_internal_set_attacker_id(int32_t value) {
  
  _impl_.attacker_id_ = value;
}
inline void MS_DIE::set_attacker_id(int32_t value) {
  _internal_set_attacker_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_DIE.attacker_id)
}

// -------------------------------------------------------------------

// MS_CHANGE_HP

// int32 object_id = 1;
inline void MS_CHANGE_HP::clear_object_id() {
  _impl_.object_id_ = 0;
}
inline int32_t MS_CHANGE_HP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline int32_t MS_CHANGE_HP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_CHANGE_HP.object_id)
  return _internal_object_id();
}
inline void MS_CHANGE_HP::_internal_set_object_id(int32_t value) {
  
  _impl_.object_id_ = value;
}
inline void MS_CHANGE_HP::set_object_id(int32_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_CHANGE_HP.object_id)
}

// int32 hp = 2;
inline void MS_CHANGE_HP::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t MS_CHANGE_HP::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t MS_CHANGE_HP::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_CHANGE_HP.hp)
  return _internal_hp();
}
inline void MS_CHANGE_HP::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void MS_CHANGE_HP::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_CHANGE_HP.hp)
}

// -------------------------------------------------------------------

// MS_CONNECTED

// -------------------------------------------------------------------

// UC_LOGIN

// string unique_id = 1;
inline void UC_LOGIN::clear_unique_id() {
  _impl_.unique_id_.ClearToEmpty();
}
inline const std::string& UC_LOGIN::unique_id() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_LOGIN.unique_id)
  return _internal_unique_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UC_LOGIN::set_unique_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.UC_LOGIN.unique_id)
}
inline std::string* UC_LOGIN::mutable_unique_id() {
  std::string* _s = _internal_mutable_unique_id();
  // @@protoc_insertion_point(field_mutable:Protocol.UC_LOGIN.unique_id)
  return _s;
}
inline const std::string& UC_LOGIN::_internal_unique_id() const {
  return _impl_.unique_id_.Get();
}
inline void UC_LOGIN::_internal_set_unique_id(const std::string& value) {
  
  _impl_.unique_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UC_LOGIN::_internal_mutable_unique_id() {
  
  return _impl_.unique_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UC_LOGIN::release_unique_id() {
  // @@protoc_insertion_point(field_release:Protocol.UC_LOGIN.unique_id)
  return _impl_.unique_id_.Release();
}
inline void UC_LOGIN::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  _impl_.unique_id_.SetAllocated(unique_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_id_.IsDefault()) {
    _impl_.unique_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.UC_LOGIN.unique_id)
}

// int32 room_id = 2;
inline void UC_LOGIN::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t UC_LOGIN::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t UC_LOGIN::room_id() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_LOGIN.room_id)
  return _internal_room_id();
}
inline void UC_LOGIN::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void UC_LOGIN::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Protocol.UC_LOGIN.room_id)
}

// -------------------------------------------------------------------

// MS_LOGIN

// int32 login_ok = 1;
inline void MS_LOGIN::clear_login_ok() {
  _impl_.login_ok_ = 0;
}
inline int32_t MS_LOGIN::_internal_login_ok() const {
  return _impl_.login_ok_;
}
inline int32_t MS_LOGIN::login_ok() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_LOGIN.login_ok)
  return _internal_login_ok();
}
inline void MS_LOGIN::_internal_set_login_ok(int32_t value) {
  
  _impl_.login_ok_ = value;
}
inline void MS_LOGIN::set_login_ok(int32_t value) {
  _internal_set_login_ok(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_LOGIN.login_ok)
}

// repeated .Protocol.LobbyPlayerInfo players = 2;
inline int MS_LOGIN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int MS_LOGIN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::LobbyPlayerInfo* MS_LOGIN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MS_LOGIN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
MS_LOGIN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MS_LOGIN.players)
  return &_impl_.players_;
}
inline const ::Protocol::LobbyPlayerInfo& MS_LOGIN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::LobbyPlayerInfo& MS_LOGIN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MS_LOGIN.players)
  return _internal_players(index);
}
inline ::Protocol::LobbyPlayerInfo* MS_LOGIN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::LobbyPlayerInfo* MS_LOGIN::add_players() {
  ::Protocol::LobbyPlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.MS_LOGIN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
MS_LOGIN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.MS_LOGIN.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// UC_CREATE_PLAYER

// string name = 1;
inline void UC_CREATE_PLAYER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UC_CREATE_PLAYER::name() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_CREATE_PLAYER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UC_CREATE_PLAYER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.UC_CREATE_PLAYER.name)
}
inline std::string* UC_CREATE_PLAYER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.UC_CREATE_PLAYER.name)
  return _s;
}
inline const std::string& UC_CREATE_PLAYER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UC_CREATE_PLAYER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UC_CREATE_PLAYER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UC_CREATE_PLAYER::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.UC_CREATE_PLAYER.name)
  return _impl_.name_.Release();
}
inline void UC_CREATE_PLAYER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.UC_CREATE_PLAYER.name)
}

// -------------------------------------------------------------------

// MS_CREATE_PLAYER

// .Protocol.LobbyPlayerInfo player = 1;
inline bool MS_CREATE_PLAYER::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool MS_CREATE_PLAYER::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::LobbyPlayerInfo& MS_CREATE_PLAYER::_internal_player() const {
  const ::Protocol::LobbyPlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::LobbyPlayerInfo&>(
      ::Protocol::_LobbyPlayerInfo_default_instance_);
}
inline const ::Protocol::LobbyPlayerInfo& MS_CREATE_PLAYER::player() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_CREATE_PLAYER.player)
  return _internal_player();
}
inline void MS_CREATE_PLAYER::unsafe_arena_set_allocated_player(
    ::Protocol::LobbyPlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MS_CREATE_PLAYER.player)
}
inline ::Protocol::LobbyPlayerInfo* MS_CREATE_PLAYER::release_player() {
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* MS_CREATE_PLAYER::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.MS_CREATE_PLAYER.player)
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* MS_CREATE_PLAYER::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::LobbyPlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::LobbyPlayerInfo* MS_CREATE_PLAYER::mutable_player() {
  ::Protocol::LobbyPlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.MS_CREATE_PLAYER.player)
  return _msg;
}
inline void MS_CREATE_PLAYER::set_allocated_player(::Protocol::LobbyPlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MS_CREATE_PLAYER.player)
}

// -------------------------------------------------------------------

// UC_ENTER_GAME

// string name = 1;
inline void UC_ENTER_GAME::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UC_ENTER_GAME::name() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_ENTER_GAME.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UC_ENTER_GAME::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.UC_ENTER_GAME.name)
}
inline std::string* UC_ENTER_GAME::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.UC_ENTER_GAME.name)
  return _s;
}
inline const std::string& UC_ENTER_GAME::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UC_ENTER_GAME::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UC_ENTER_GAME::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UC_ENTER_GAME::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.UC_ENTER_GAME.name)
  return _impl_.name_.Release();
}
inline void UC_ENTER_GAME::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.UC_ENTER_GAME.name)
}

// -------------------------------------------------------------------

// MS_ITEM_LIST

// repeated .Protocol.ItemInfo items = 1;
inline int MS_ITEM_LIST::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int MS_ITEM_LIST::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* MS_ITEM_LIST::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MS_ITEM_LIST.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
MS_ITEM_LIST::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MS_ITEM_LIST.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& MS_ITEM_LIST::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& MS_ITEM_LIST::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MS_ITEM_LIST.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* MS_ITEM_LIST::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* MS_ITEM_LIST::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.MS_ITEM_LIST.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
MS_ITEM_LIST::items() const {
  // @@protoc_insertion_point(field_list:Protocol.MS_ITEM_LIST.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// MS_ADD_ITEM

// repeated .Protocol.ItemInfo items = 1;
inline int MS_ADD_ITEM::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int MS_ADD_ITEM::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* MS_ADD_ITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.MS_ADD_ITEM.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
MS_ADD_ITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.MS_ADD_ITEM.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& MS_ADD_ITEM::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& MS_ADD_ITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.MS_ADD_ITEM.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* MS_ADD_ITEM::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* MS_ADD_ITEM::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.MS_ADD_ITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
MS_ADD_ITEM::items() const {
  // @@protoc_insertion_point(field_list:Protocol.MS_ADD_ITEM.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// UC_EQUIP_ITEM

// int32 item_db_id = 1;
inline void UC_EQUIP_ITEM::clear_item_db_id() {
  _impl_.item_db_id_ = 0;
}
inline int32_t UC_EQUIP_ITEM::_internal_item_db_id() const {
  return _impl_.item_db_id_;
}
inline int32_t UC_EQUIP_ITEM::item_db_id() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_EQUIP_ITEM.item_db_id)
  return _internal_item_db_id();
}
inline void UC_EQUIP_ITEM::_internal_set_item_db_id(int32_t value) {
  
  _impl_.item_db_id_ = value;
}
inline void UC_EQUIP_ITEM::set_item_db_id(int32_t value) {
  _internal_set_item_db_id(value);
  // @@protoc_insertion_point(field_set:Protocol.UC_EQUIP_ITEM.item_db_id)
}

// bool equipped = 2;
inline void UC_EQUIP_ITEM::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool UC_EQUIP_ITEM::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool UC_EQUIP_ITEM::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_EQUIP_ITEM.equipped)
  return _internal_equipped();
}
inline void UC_EQUIP_ITEM::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void UC_EQUIP_ITEM::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.UC_EQUIP_ITEM.equipped)
}

// -------------------------------------------------------------------

// MS_EQUIP_ITEM

// int32 item_db_id = 1;
inline void MS_EQUIP_ITEM::clear_item_db_id() {
  _impl_.item_db_id_ = 0;
}
inline int32_t MS_EQUIP_ITEM::_internal_item_db_id() const {
  return _impl_.item_db_id_;
}
inline int32_t MS_EQUIP_ITEM::item_db_id() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_EQUIP_ITEM.item_db_id)
  return _internal_item_db_id();
}
inline void MS_EQUIP_ITEM::_internal_set_item_db_id(int32_t value) {
  
  _impl_.item_db_id_ = value;
}
inline void MS_EQUIP_ITEM::set_item_db_id(int32_t value) {
  _internal_set_item_db_id(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_EQUIP_ITEM.item_db_id)
}

// bool equipped = 2;
inline void MS_EQUIP_ITEM::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool MS_EQUIP_ITEM::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool MS_EQUIP_ITEM::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_EQUIP_ITEM.equipped)
  return _internal_equipped();
}
inline void MS_EQUIP_ITEM::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void MS_EQUIP_ITEM::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.MS_EQUIP_ITEM.equipped)
}

// -------------------------------------------------------------------

// MS_CHANGE_STAT

// .Protocol.StatInfo stat_info = 1;
inline bool MS_CHANGE_STAT::_internal_has_stat_info() const {
  return this != internal_default_instance() && _impl_.stat_info_ != nullptr;
}
inline bool MS_CHANGE_STAT::has_stat_info() const {
  return _internal_has_stat_info();
}
inline const ::Protocol::StatInfo& MS_CHANGE_STAT::_internal_stat_info() const {
  const ::Protocol::StatInfo* p = _impl_.stat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& MS_CHANGE_STAT::stat_info() const {
  // @@protoc_insertion_point(field_get:Protocol.MS_CHANGE_STAT.stat_info)
  return _internal_stat_info();
}
inline void MS_CHANGE_STAT::unsafe_arena_set_allocated_stat_info(
    ::Protocol::StatInfo* stat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_info_);
  }
  _impl_.stat_info_ = stat_info;
  if (stat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.MS_CHANGE_STAT.stat_info)
}
inline ::Protocol::StatInfo* MS_CHANGE_STAT::release_stat_info() {
  
  ::Protocol::StatInfo* temp = _impl_.stat_info_;
  _impl_.stat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* MS_CHANGE_STAT::unsafe_arena_release_stat_info() {
  // @@protoc_insertion_point(field_release:Protocol.MS_CHANGE_STAT.stat_info)
  
  ::Protocol::StatInfo* temp = _impl_.stat_info_;
  _impl_.stat_info_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* MS_CHANGE_STAT::_internal_mutable_stat_info() {
  
  if (_impl_.stat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.stat_info_ = p;
  }
  return _impl_.stat_info_;
}
inline ::Protocol::StatInfo* MS_CHANGE_STAT::mutable_stat_info() {
  ::Protocol::StatInfo* _msg = _internal_mutable_stat_info();
  // @@protoc_insertion_point(field_mutable:Protocol.MS_CHANGE_STAT.stat_info)
  return _msg;
}
inline void MS_CHANGE_STAT::set_allocated_stat_info(::Protocol::StatInfo* stat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_info_);
  }
  if (stat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat_info));
    if (message_arena != submessage_arena) {
      stat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_info_ = stat_info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.MS_CHANGE_STAT.stat_info)
}

// -------------------------------------------------------------------

// MS_PING

// -------------------------------------------------------------------

// UC_PONG

// -------------------------------------------------------------------

// UC_CHANGE_ROOM

// int32 room_id = 1;
inline void UC_CHANGE_ROOM::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t UC_CHANGE_ROOM::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t UC_CHANGE_ROOM::room_id() const {
  // @@protoc_insertion_point(field_get:Protocol.UC_CHANGE_ROOM.room_id)
  return _internal_room_id();
}
inline void UC_CHANGE_ROOM::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void UC_CHANGE_ROOM::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Protocol.UC_CHANGE_ROOM.room_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
